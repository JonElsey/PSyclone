from psyGen import PSy,Invokes,Invoke,Schedule,Loop,Kern,Arguments,Argument

class DynamoPSy(PSy):
    def __init__(self,invoke_info):
        PSy.__init__(self,invoke_info)
        self._invokes=DynamoInvokes(invoke_info.calls)
    @property
    def gen(self):
        '''
        Generate PSy code for the Dynamo0.1 api.

        :rtype: ast

        '''
        from f2pygen import ModuleGen, UseGen

        # create an empty PSy layer module
        psy_module=ModuleGen(self.name)
        # include the lfric module
        lfric_use=UseGen(psy_module,name="lfric")
        psy_module.add(lfric_use)
        # add all invoke specific information
        self.invokes.genCode(psy_module)
        return psy_module.root

class DynamoInvokes(Invokes):
    def __init__(self,alg_calls):
        Invokes.__init__(self,alg_calls,DynInvoke)

class DynInvoke(Invoke):
    def __init__(self,alg_invocation,idx):
        Invoke.__init__(self,alg_invocation,idx,DynSchedule)

    def genCode(self,parent):
        from f2pygen import SubroutineGen,TypeDeclGen
        # create the subroutine
        invoke_sub=SubroutineGen(parent,name=self.name,args=self.unique_args)
        self.schedule.genCode(invoke_sub)
        parent.add(invoke_sub)
        # add the subroutine argument declarations
        my_typedecl=TypeDeclGen(invoke_sub,datatype="field_type",entity_decls=self.unique_args,intent="inout")
        invoke_sub.add(my_typedecl)

class DynSchedule(Schedule):
    def __init__(self,arg):
        Schedule.__init__(self,DynLoop,DynInf,arg)

class DynLoop(Loop):
    def __init__(self,call=None,parent=None,variable_name="cell",topology_name="XXX"):
        Loop.__init__(self,DynInf,DynKern,call,parent,variable_name,topology_name)
        print dir(self.children[0])
        topology_name=self.children[0].arguments.args[0].name # hack: need to sort this out
        self._start="1"
        self._stop=topology_name+"%get_ncell()"
        self._step=""
        self._id="TBD"
    def topology_name(self,value):
        self._stop=value+"%get_ncell()"

class DynInf(Loop):
    @staticmethod
    def create(call,parent=None):
        return(Inf.create(call,parent))


class DynKern(Kern):
    def __init__(self,call,parent=None):
        Kern.__init__(self,DynKernelArguments,call,parent)
    def genCode(self,parent):
        from f2pygen import CallGen,DeclGen,AssignGen,UseGen

        # hack: we simply choose the first field as the lookup for the moment
        fieldName=self.arguments.args[0].name

        # add a dofmap lookup using first field. This needs to be generalised to work for multiple dofmaps
        parent.add(CallGen(parent,fieldName+"%vspace%get_cell_dofmap",["cell","map"]))
        parent.add(DeclGen(parent,datatype="integer",entity_decls=["cell"]))
        parent.add(DeclGen(parent,datatype="integer",pointer=True,entity_decls=["map(:)"]))

        # create the argument list on the fly so we can also create appropriate variables and lookups
        # this is generated by the Arguments class in gunghoproto
        self._arglist=[]
        self._arglist.append("nlayers")
        self._arglist.append("ndf")
        self._arglist.append("map")

        found_gauss_quad=False
        gauss_quad_arg=None
        for arg in self._arguments.args:
            if arg.requires_basis:
                basisName=arg.function_space+"_basis_"+arg.name
                self._arglist.append(basisName)
                parent.parent.add(CallGen(parent.parent,fieldName+"%vspace%get_basis",[basisName]),position=["before",parent])
                parent.add(DeclGen(parent,datatype="real",kind="dp",pointer=True,entity_decls=[basisName+"(:,:,:,:,:)"]))
            if arg.requires_diff_basis:
                raise GenerationError("differential basis has not yet been coded")
            if arg.requires_gauss_quad:
                if found_gauss_quad:
                    raise GenerationError("found more than one gaussian quadrature in this kernel")
                found_gauss_quad=True
                gauss_quad_arg=arg
            dataref="%data"
            self._arglist.append(arg.name+dataref)

        if found_gauss_quad:
            gq="%gaussian_quadrature"
            self._arglist.append(gauss_quad_arg.name+gq)

        # generate the kernel call and associated use statement
        parent.add(CallGen(parent,self._name,self._arglist))
        parent.parent.add(UseGen(parent.parent,name=self._module_name,only=True,funcnames=[self._name]))

        # declare and initialise the number of layers and the number of degrees of freedom. Needs to be generalised.
        parent.add(DeclGen(parent,datatype="integer",entity_decls=["nlayers","ndf"]))
        parent.parent.add(AssignGen(parent.parent,lhs="nlayers",rhs=fieldName+"%get_nlayers()"),position=["before",parent])
        parent.parent.add(AssignGen(parent.parent,lhs="ndf",rhs=fieldName+"%vspace%get_ndf()"),position=["before",parent])

class DynKernelArguments(Arguments):
    def __init__(self,call,parentCall):
        Arguments.__init__(self,parentCall)
        for (idx,arg) in enumerate (call.ktype.arg_descriptors):
            self._args.append(DynKernelArgument(arg,call.args[idx],parentCall))
        self._dofs={}
    @property
    def dofs(self):
        return self._dofs

class DynKernelArgument(Argument):
    def __init__(self,arg,argInfo,call):
        if arg==None and argInfo==None and call==None:return
        self._arg=arg
        Argument.__init__(self,call,argInfo,arg.access)
    @property
    def function_space(self):
        return self._arg.function_space
    @property
    def requires_basis(self):
        if self._arg.basis.lower()==".true.": return True
        if self._arg.basis.lower()==".false.": return False
        raise GenerationError("error: basis is not set to .true. or .false.")
    @property
    def requires_diff_basis(self):
        if self._arg.diff_basis.lower()==".true.": return True
        if self._arg.diff_basis.lower()==".false.": return False
        raise GenerationError("error: diff_basis is not set to .true. or .false.")
    @property
    def requires_gauss_quad(self):
        if self._arg.gauss_quad.lower()==".true.": return True
        if self._arg.gauss_quad.lower()==".false.": return False
        raise GenerationError("error: gaussian quadrature is not set to .true. or .false.")

