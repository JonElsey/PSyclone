from collections import namedtuple
import subprocess
import sys


KernelDesc = namedtuple("KernelDesc",
                        "kernel_file adj_file harness_file active_vars "
                        "coord_arg panel_id_arg, mini_app")

all_kernels = {}

all_kernels["hydrostatic_kernel"] = KernelDesc(
    kernel_file="tangent_linear/tl_hydrostatic_kernel_mod.F90",
    adj_file="adjoint/adj_hydrostatic_kernel_mod.F90",
    harness_file="test_harness/hydrostatic_kernel_harness.x90",
    active_vars="r_u exner theta moist_dyn_gas moist_dyn_tot moist_dyn_fac "
    "grad_term theta_v_e theta_v_at_quad grad_theta_v_at_quad exner_e "
    "exner_at_quad res_dot_product",
    coord_arg=-1, panel_id_arg=-1,
    mini_app="skeleton")

# Delete unused 'i_2' from adjoint kernel.
# Test passes.
all_kernels["kinetic_energy_gradient"] = KernelDesc(
    kernel_file="tangent_linear_tweaked/"
    "tl_kinetic_energy_gradient_kernel_mod_tweaked.F90",
    adj_file="adjoint/adj_kinetic_energy_gradient_kernel_mod.F90",
    harness_file="test_harness/kinetic_energy_gradient_harness.x90",
    active_vars="r_u u ru_e ke_at_quad res_dot_product mul2 u_at_quad u_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Builds but harness gives NaNs, even for run of TL kernel. I think this is
# because the random values given to the scalar parameters are not
# necessarily physically valid:
# @param[in] kappa         Ratio of rd and cp
# @param[in] rd            Specific heat of dry air at constant density
# @param[in] p_zero        Reference surface pressure
# Values for these can be found in the test suite for this kernel
# (https://code.metoffice.gov.uk/trac/lfric/browser/LFRic/trunk/linear/
# unit-test/kernel/tl_rhs_project_eos_kernel_mod_test.pf) which gives:
# p_zero   = 100000.0_r_def
# rd       = 300.0_r_def
# cp       = 1000.0_r_def
# and therefore kappa = 300.0/1000.0 = 0.3. However, even with these values the
# TL kernel still gives NaNs.
# However, this kernel has been tested by the MO as part of the adjoint to the
# RHS alg. and works in that case.
all_kernels["rhs_project_eos"] = KernelDesc(
    kernel_file="tangent_linear/tl_rhs_project_eos_kernel_mod.F90",
    adj_file="adjoint/adj_rhs_project_eos_kernel_mod.F90",
    harness_file="test_harness/rhs_project_eos_harness.x90",
    active_vars="rhs_eos exner rho theta moist_dyn_gas eos exner_quad "
    "theta_vd_quad rho_quad rho_e exner_e theta_vd_e",
    coord_arg=10, panel_id_arg=11, mini_app="gravity_wave")

# Argument list generated by PSyclone for invoke of adjointed kernel does
# not match the kernel interface because get extra dof maps related to the
# quadrature being evaluated for function spaces of fields that are modified
# in the adjoint but not in the TL. Once the adjoint kernel argument list
# has been updated appropriately then the test harness runs successfully.
all_kernels["rhs_sample_eos"] = KernelDesc(
    kernel_file="tangent_linear/tl_rhs_sample_eos_kernel_mod.F90",
    adj_file="adjoint/adj_rhs_sample_eos_kernel_mod.F90",
    harness_file="test_harness/rhs_sample_eos_harness.x90",
    active_vars="rhs_eos exner rho theta moist_dyn_gas exner_cell "
    "theta_vd_cell rho_cell rho_e exner_e theta_vd_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes!
all_kernels["dg_inc_matrix_vector"] = KernelDesc(
    adj_file="adjoint/adj_dg_inc_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/dg_inc_matrix_vector_kernel_mod.F90",
    harness_file="test_harness/dg_inc_matrix_vector_harness.x90",
    active_vars="lhs x lhs_e x_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes!
all_kernels["moist_dyn_mass"] = KernelDesc(
    adj_file="adjoint/adj_moist_dyn_mass_kernel_mod.F90",
    kernel_file="tangent_linear/tl_moist_dyn_mass_kernel_mod.F90",
    harness_file="test_harness/moist_dyn_mass_harness.x90",
    active_vars="moist_dyn_tot mr_v mr_cl mr_r mr_ci mr_s mr_g mr_v_at_dof "
    "mr_cl_at_dof mr_r_at_dof mr_ci_at_dof mr_s_at_dof mr_g_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["transpose_matrix_vector"] = KernelDesc(
    adj_file="adjoint/adj_transpose_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/transpose_matrix_vector_kernel_mod.F90",
    harness_file="test_harness/transpose_matrix_vector_harness.x90",
    active_vars="lhs lhs_e x_e x",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Has stencil.
all_kernels["pressure_gradient_bd"] = KernelDesc(
    adj_file="adjoint/adj_pressure_gradient_bd_kernel_mod.F90",
    kernel_file="tangent_linear/tl_pressure_gradient_bd_kernel_mod.F90",
    harness_file="test_harness/pressure_gradient_bd_harness.x90",
    active_vars="r_u_bd exner pressure_gradient_bd_e bdary_term exner_av "
    "theta_v_at_fquad theta_v_e exner_e exner_next_e theta moist_dyn_tot "
    "moist_dyn_gas",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["matrix_vector"] = KernelDesc(
    adj_file="adjoint/adj_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/matrix_vector_kernel_mod.F90",
    harness_file="test_harness/matrix_vector_harness.x90",
    active_vars="lhs x lhs_e x_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Must use gravity-wave mini-app so that planet_config_mod contains 'Rd'
# FAILS: test harness gives NaNs currently.
all_kernels["project_eos_pressure"] = KernelDesc(
    adj_file="adjoint/adj_project_eos_pressure_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_project_eos_pressure_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/project_eos_pressure_harness.x90",
    active_vars="exner rho exner_e r_exner exner_at_quad rho_at_quad rho_e "
    "tmp_exner theta theta_vd_e theta_vd_at_quad moist_dyn_gas",
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# Change coord. field to be on Wchi.
# 'i_2' in adjoint kernel declared but unused.
# Passes once that declaration removed.
all_kernels["kinetic_energy_gradient"] = KernelDesc(
    adj_file="adjoint/adj_kinetic_energy_gradient_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_kinetic_energy_gradient_kernel_"
    "mod_tweaked.F90",
    harness_file="test_harness/kinetic_energy_gradient_harness.x90",
    active_vars="r_u ru_e ke_at_quad res_dot_product mul2 u_at_quad u_e u",
    coord_arg=4, panel_id_arg=5, mini_app="skeleton")

# Change coord. field to be on Wchi.
# i_3, idx_1_1, idx_2_1 declared but unused.
# Passes once that declaration removed.
all_kernels["vorticity_advection"] = KernelDesc(
    adj_file="adjoint/adj_vorticity_advection_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_vorticity_advection_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/adj_vorticity_advection_harness.x90",
    active_vars="r_u res_dot_product vorticity_term cross_product1 "
    "cross_product2 j_vorticity u_at_quad mul2 vorticity_at_quad wind "
    "vorticity",
    coord_arg=6, panel_id_arg=7, mini_app="skeleton")

# Kernel imports recip_epsilon from planet_config_mod but compiler says the
# module doesn't have such a symbol. However, modifying the gravity-wave
# miniapp to run the test harness instead works.
all_kernels["moist_dyn_gas"] = KernelDesc(
    adj_file="adjoint/adj_moist_dyn_gas_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_moist_dyn_gas_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/moist_dyn_gas_harness.x90",
    active_vars="moist_dyn_gas mr_v mr_v_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# Passes.
all_kernels["moist_dyn_mass"] = KernelDesc(
    adj_file="adjoint/adj_moist_dyn_mass_kernel_mod.F90",
    kernel_file="tangent_linear/tl_moist_dyn_mass_kernel_mod.F90",
    harness_file="test_harness/moist_dyn_mass_harness.x90",
    active_vars="moist_dyn_tot mr_v mr_cl mr_r mr_ci mr_s mr_g mr_v_at_dof "
    "mr_cl_at_dof mr_r_at_dof mr_ci_at_dof mr_s_at_dof mr_g_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")


def main():
    ''' '''
    kernels_to_process = []
    for arg in sys.argv:
        if arg in all_kernels:
            kernels_to_process.append((arg, all_kernels[arg]))

    makefile = "Makefile_harness"

    for name, kern in kernels_to_process:

        arg_list = ["make", f"KERNEL_FILE={kern.kernel_file}",
                    f"ADJ_FILE={kern.adj_file}",
                    f"HARNESS_FILE={kern.harness_file}"]
        geom_args = []
        if kern.coord_arg > -1:
            geom_args.append(f"-coord-arg {kern.coord_arg}")
        if kern.panel_id_arg > -1:
            geom_args.append(f"-panel-id-arg {kern.panel_id_arg}")
        if geom_args:
            geom_arg_txt = ' '.join(geom_args)
            arg_list.append(f"GEOM_ARGS={geom_arg_txt}")
        arg_list.append(f"MINI_APP={kern.mini_app}")
        arg_list.extend([f"ACTIVE_VARS={kern.active_vars}", "-f", makefile])

        print(f"Running: '{' '.join(arg_list)}'")
        try:
            process = subprocess.Popen(arg_list, stdout=subprocess.PIPE,
                                       stderr=subprocess.STDOUT)
            for c in iter(lambda: process.stdout.read(1), b""):
                sys.stdout.buffer.write(c)

        except OSError as err:
            print(f"Failed to process kernel {name}: {err}",
                  file=sys.stderr)
            continue


if __name__ == "__main__":
    main()
