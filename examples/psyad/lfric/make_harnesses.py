#!/usr/bin/env python
from collections import namedtuple
import argparse
import subprocess
import sys


KernelDesc = namedtuple("KernelDesc",
                        "passing kernel_file adj_file harness_file active_vars"
                        " coord_arg panel_id_arg mini_app")
# 'Kernels' that have no metadata and therefore must be treated as a
# standard Fortran subroutine by PSyAD (i.e. no 'API').
NO_METADATA_KERNELS = ["calc_exner_pointwise"]

all_kernels = {}

# Passes.
all_kernels["hydrostatic_kernel"] = KernelDesc(
    passing=True,
    kernel_file="tangent_linear/tl_hydrostatic_kernel_mod.F90",
    adj_file="adjoint/adj_hydrostatic_kernel_mod.F90",
    harness_file="test_harness/hydrostatic_kernel_harness.x90",
    active_vars="r_u exner theta moist_dyn_gas moist_dyn_tot moist_dyn_fac "
    "grad_term theta_v_e theta_v_at_quad grad_theta_v_at_quad exner_e "
    "exner_at_quad res_dot_product",
    coord_arg=-1, panel_id_arg=-1,
    mini_app="skeleton")

# Delete unused 'i_2' from adjoint kernel.
# Test passes.
all_kernels["kinetic_energy_gradient"] = KernelDesc(
    passing=True,
    kernel_file="tangent_linear_tweaked/"
    "tl_kinetic_energy_gradient_kernel_mod_tweaked.F90",
    adj_file="adjoint/adj_kinetic_energy_gradient_kernel_mod.F90",
    harness_file="test_harness/kinetic_energy_gradient_harness.x90",
    active_vars="r_u u ru_e ke_at_quad res_dot_product mul2 u_at_quad u_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Builds but harness gives NaNs, even for run of TL kernel. I think this is
# because the random values given to the scalar parameters are not
# necessarily physically valid:
# @param[in] kappa         Ratio of rd and cp
# @param[in] rd            Specific heat of dry air at constant density
# @param[in] p_zero        Reference surface pressure
# Values for these can be found in the test suite for this kernel
# (https://code.metoffice.gov.uk/trac/lfric/browser/LFRic/trunk/linear/
# unit-test/kernel/tl_rhs_project_eos_kernel_mod_test.pf) which gives:
# p_zero   = 100000.0_r_def
# rd       = 300.0_r_def
# cp       = 1000.0_r_def
# and therefore kappa = 300.0/1000.0 = 0.3. However, even with these values the
# *TL kernel* (not the adjoint) still gives NaNs.
# However, this kernel has been tested by the MO as part of the adjoint to the
# RHS alg. and works in that case.
all_kernels["rhs_project_eos"] = KernelDesc(
    passing=False,
    kernel_file="tangent_linear/tl_rhs_project_eos_kernel_mod.F90",
    adj_file="adjoint/adj_rhs_project_eos_kernel_mod.F90",
    harness_file="test_harness/rhs_project_eos_harness.x90",
    active_vars="rhs_eos exner rho theta moist_dyn_gas eos exner_quad "
    "theta_vd_quad rho_quad rho_e exner_e theta_vd_e",
    coord_arg=10, panel_id_arg=11, mini_app="gravity_wave")

# Argument list generated by PSyclone for invoke of adjointed kernel does
# not match the kernel interface because get extra dof maps related to the
# quadrature being evaluated for function spaces of fields that are modified
# in the adjoint but not in the TL. Once the adjoint kernel argument list
# has been updated appropriately then the test harness runs successfully.
all_kernels["rhs_sample_eos"] = KernelDesc(
    passing=True,
    kernel_file="tangent_linear/tl_rhs_sample_eos_kernel_mod.F90",
    adj_file="adjoint/adj_rhs_sample_eos_kernel_mod.F90",
    harness_file="test_harness/rhs_sample_eos_harness.x90",
    active_vars="rhs_eos exner rho theta moist_dyn_gas exner_cell "
    "theta_vd_cell rho_cell rho_e exner_e theta_vd_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["dg_inc_matrix_vector"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_dg_inc_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/dg_inc_matrix_vector_kernel_mod.F90",
    harness_file="test_harness/dg_inc_matrix_vector_harness.x90",
    active_vars="lhs x lhs_e x_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["moist_dyn_mass"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_moist_dyn_mass_kernel_mod.F90",
    kernel_file="tangent_linear/tl_moist_dyn_mass_kernel_mod.F90",
    harness_file="test_harness/moist_dyn_mass_harness.x90",
    active_vars="moist_dyn_tot mr_v mr_cl mr_r mr_ci mr_s mr_g mr_v_at_dof "
    "mr_cl_at_dof mr_r_at_dof mr_ci_at_dof mr_s_at_dof mr_g_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["transpose_matrix_vector"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_transpose_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/transpose_matrix_vector_kernel_mod.F90",
    harness_file="test_harness/transpose_matrix_vector_harness.x90",
    active_vars="lhs lhs_e x_e x",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Has stencil.
all_kernels["pressure_gradient_bd"] = KernelDesc(
    passing=False,
    adj_file="adjoint/adj_pressure_gradient_bd_kernel_mod.F90",
    kernel_file="tangent_linear/tl_pressure_gradient_bd_kernel_mod.F90",
    harness_file="test_harness/pressure_gradient_bd_harness.x90",
    active_vars="r_u_bd exner pressure_gradient_bd_e bdary_term exner_av "
    "theta_v_at_fquad theta_v_e exner_e exner_next_e theta moist_dyn_tot "
    "moist_dyn_gas",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
all_kernels["matrix_vector"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_matrix_vector_kernel_mod.F90",
    kernel_file="tangent_linear/matrix_vector_kernel_mod.F90",
    harness_file="test_harness/matrix_vector_harness.x90",
    active_vars="lhs x lhs_e x_e",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# FAILS: TL kern in test harness gives NaNs currently.
# Running with FPE handling on bombs out in 'gw_init_fields_alg_mod', i.e.
# before we get to the actual adjoint test harness. (This does not happen
# on head of trunk.)
all_kernels["project_eos_pressure"] = KernelDesc(
    passing=False,
    adj_file="adjoint/adj_project_eos_pressure_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_project_eos_pressure_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/project_eos_pressure_harness.x90",
    active_vars="exner rho exner_e r_exner exner_at_quad rho_at_quad rho_e "
    "tmp_exner theta theta_vd_e theta_vd_at_quad moist_dyn_gas",
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# Change coord. field to be on Wchi.
# 'i_2' in adjoint kernel declared but unused.
# Passes once that declaration removed.
all_kernels["kinetic_energy_gradient"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_kinetic_energy_gradient_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_kinetic_energy_gradient_kernel_"
    "mod_tweaked.F90",
    harness_file="test_harness/kinetic_energy_gradient_harness.x90",
    active_vars="r_u ru_e ke_at_quad res_dot_product mul2 u_at_quad u_e u",
    coord_arg=4, panel_id_arg=5, mini_app="skeleton")

# Change coord. field to be on Wchi.
# i_3, idx_1_1, idx_2_1 declared but unused.
# Passes once that declaration removed.
# Status doc. number = 23
all_kernels["vorticity_advection"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_vorticity_advection_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_vorticity_advection_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/vorticity_advection_harness.x90",
    active_vars="r_u res_dot_product vorticity_term cross_product1 "
    "cross_product2 j_vorticity u_at_quad mul2 vorticity_at_quad wind "
    "vorticity",
    coord_arg=6, panel_id_arg=7, mini_app="skeleton")

# Passes.
# Status doc. number = 1
all_kernels["moist_dyn_gas"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_moist_dyn_gas_kernel_mod.F90",
    kernel_file="tangent_linear_tweaked/tl_moist_dyn_gas_kernel_mod_"
    "tweaked.F90",
    harness_file="test_harness/moist_dyn_gas_harness.x90",
    active_vars="moist_dyn_gas mr_v mr_v_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# Passes.
# Status doc. number = 2
all_kernels["moist_dyn_mass"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_moist_dyn_mass_kernel_mod.F90",
    kernel_file="tangent_linear/tl_moist_dyn_mass_kernel_mod.F90",
    harness_file="test_harness/moist_dyn_mass_harness.x90",
    active_vars="moist_dyn_tot mr_v mr_cl mr_r mr_ci mr_s mr_g mr_v_at_dof "
    "mr_cl_at_dof mr_r_at_dof mr_ci_at_dof mr_s_at_dof mr_g_at_dof",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes but cannot copy TL kernel into test harness because it's identical
# to the kernel on trunk.
# Status doc. number = 8
all_kernels["w3_advective_update"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_w3_advective_update_kernel_mod.F90",
    kernel_file="tangent_linear/w3_advective_update_kernel_mod.F90",
    harness_file="test_harness/w3_advective_update_harness.x90",
    active_vars="advective_increment u v w wind",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# #1458 - passive scalars are assigned to multiple times. In the tweaked
# version I've changed the code so that a new scalar is used for each
# assignment. Test then passes.
# Status doc. number = 9
all_kernels["poly_advective"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_poly_advective_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/tl_poly_advective_kernel_"
                 "mod_tweaked.F90"),
    harness_file="test_harness/poly_advective_harness.x90",
    active_vars="advective dtdx dtdy v u tracer wind",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Scalar of type 'logical' not supported - #2013.
# #1458 - passive scalar computed in a loop alongside active variable. Must
# be separated out.
# Passes once that limitation removed from test-harness generation and unused
# scalar removed from test harness.
# TODO record that 'tweaked' harness must be used.
# Status doc. number = 10
all_kernels["poly1d_vert_adv"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_poly1d_vert_adv_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/tl_poly1d_vert_adv_kernel_mod_"
                 "tweaked.F90"),
    harness_file="test_harness/poly1d_vert_adv_harness.x90",
    active_vars="advective wind dpdz tracer",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Has stencil
# Status doc. number = 11
all_kernels["poly1d_w3_reconstruction"] = KernelDesc(
    passing=False,
    adj_file="adjoint/lbl_adj_poly1d_w3_reconstruction_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/poly1d_w3_reconstruction_kernel_"
                 "mod_tweaked.F90"),
    harness_file="test_harness/poly1d_w3_reconstruction_harness.x90",
    active_vars="reconstruction polynomial_tracer tracer",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Has logical scalar argument and loop that updates both active and passive
# vars.
# Generated test harness has unused scalars.
# Passes (once above issues fixed).
# Status doc. number = 12
all_kernels["poly1d_vert_w3_reconstruction"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_poly1d_vert_w3_reconstruction_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/tl_poly1d_vert_w3_reconstruction_"
                 "kernel_mod_tweaked.F90"),
    harness_file="test_harness/poly1d_vert_w3_reconstruction_harness.x90",
    active_vars="reconstruction polynomial_tracer tracer",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
# Status doc. number = 13
all_kernels["convert_hdiv_field"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_convert_hdiv_field_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/"
                 "convert_hdiv_field_kernel_mod_tweaked.F90"),
    harness_file="test_harness/convert_hdiv_field_harness.x90",
    active_vars=("physical_field1 physical_field2 physical_field3 "
                 "vector_out vector_in computational_field"),
    coord_arg=3, panel_id_arg=4, mini_app="gravity_wave")

# Passes.
# Status doc. number = 14
all_kernels["combine_w2_field"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_combine_w2_field_kernel_mod.F90",
    kernel_file="tangent_linear/combine_w2_field_kernel_mod.F90",
    harness_file="test_harness/combine_w2_field_harness.x90",
    active_vars="uvw w uv",
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# tl_calc_exner_pointwise [-a rho theta exner]
# Has no metadata.
# Status doc. number = 17
all_kernels["calc_exner_pointwise"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_calc_exner_pointwise_mod.F90",
    kernel_file=("tangent_linear_tweaked/tl_calc_exner_pointwise_mod_"
                 "tweaked.F90"),
    harness_file="test_harness/calc_exner_pointwise_harness.f90",
    active_vars="rho theta exner",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
# Status doc. number = 18
all_kernels["sample_flux"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_sample_flux_kernel_mod.F90",
    kernel_file="tangent_linear/sample_flux_kernel_mod.F90",
    harness_file="test_harness/sample_flux_harness.x90",
    active_vars="flux u",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes once adj. kernel updated with additional args.
# Status doc. number = 24
all_kernels["rhs_sample_eos"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_rhs_sample_eos_kernel_mod.F90",
    kernel_file="tangent_linear/tl_rhs_sample_eos_kernel_mod.F90",
    harness_file="test_harness/rhs_sample_eos_harness.x90",
    active_vars=("rhs_eos exner_cell theta_vd_cell rho_cell rho_e exner_e "
                 "theta_vd_e rho exner theta moist_dyn_gas"),
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Gravity_wave test harness gives NaNs.
# Status doc. number = 25
all_kernels["sample_eos_pressure"] = KernelDesc(
    passing=False,
    adj_file="adjoint/adj_sample_eos_pressure_kernel_mod.F90",
    kernel_file=("tangent_linear_tweaked/tl_sample_eos_pressure_kernel_"
                 "mod_tweaked.F90"),
    harness_file="test_harness/sample_eos_pressure_harness.x90",
    active_vars=("exner tmp_exner theta_vd_cell theta_vd_e theta "
                 "moist_dyn_gas rho_cell rho_e rho"),
    coord_arg=-1, panel_id_arg=-1, mini_app="gravity_wave")

# Fails but would pass if 'uvw' zeroed before kernel runs.
# Status doc. number = 15
all_kernels["split_w2_field"] = KernelDesc(
    passing=False,
    adj_file="adjoint/adj_split_w2_field_kernel_mod.F90",
    kernel_file="tangent_linear/split_w2_field_kernel_mod.F90",
    harness_file="test_harness/split_w2_field_harness.x90",
    active_vars="uv uvw w",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Has stencil.
# Status doc. number = 26
all_kernels["tracer_viscosity"] = KernelDesc(
    passing=False,
    adj_file="adjoint/adj_tracer_viscosity_kernel_mod.F90",
    kernel_file="tangent_linear/tracer_viscosity_kernel_mod.F90",
    harness_file="test_harness/tracer_viscosity_harness.x90",
    active_vars="theta_inc viscosity_mu",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes once adjoint argument list updated with additional
# basis and diff-basis arrays.
# Status doc. number = 29
all_kernels["strong_curl"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_strong_curl_kernel_mod.F90",
    kernel_file="tangent_linear/strong_curl_kernel_mod.F90",
    harness_file="test_harness/strong_curl_harness.x90",
    active_vars="xi res_dot_product curl_u u",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

# Passes.
# Status doc. number = 28
all_kernels["w2_to_w1_projection"] = KernelDesc(
    passing=True,
    adj_file="adjoint/adj_w2_to_w1_projection_kernel_mod.F90",
    kernel_file="tangent_linear/w2_to_w1_projection_kernel_mod.F90",
    harness_file="test_harness/w2_to_w1_projection_harness.x90",
    active_vars="v_w1 u_w2 vu res_dot_product wind",
    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")

#all_kernels[""] = KernelDesc(
#    adj_file="adjoint/",
#    kernel_file="tangent_linear/",
#    harness_file="test_harness/_harness.x90",
#    active_vars="",
#    coord_arg=-1, panel_id_arg=-1, mini_app="skeleton")


def main(cmd_args):
    ''' '''
    parser = argparse.ArgumentParser(description="Test adjoint kernel code")
    parser.add_argument('-all', help='Test all kernels marked as passing',
                        action='store_true')
    parser.add_argument('-kernel', help='name of kernel to test')
    parser.add_argument('-n', dest='nproc',
                        help='Number of threads to instruct make to use',
                        type=int, default=1)
    args = parser.parse_args(cmd_args)

    if args.all:
        # We test all kernels marked as 'passing'
        kernels_to_process = [(kname, kern) for (kname, kern) in
                              all_kernels.items() if kern.passing]
    elif args.kernel:
        if args.kernel not in all_kernels:
            print("Not a recognised kernel name", file=sys.stderr)
            sys.exit(1)
        kernels_to_process = [(args.kernel, all_kernels[args.kernel])]
    else:
        print("One of -all or -kernel <kernel-name> must be specified.",
              file=sys.stderr)
        sys.exit(1)

#    tar_args = []
#    for arg in sys.argv:
#        if arg in all_kernels:
#            kern = all_kernels[arg]
#            psyad_output = kern.adj_file.replace("adjoint/",
#                                                 "adjoint_partial/")
#            tar_args.extend(
#                [kern.kernel_file, kern.adj_file, psyad_output,
#                 kern.harness_file])

    #print(" ".join(tar_args))
    #exit(0)
    makefile = "Makefile_harness"

    for name, kern in kernels_to_process:

        # For each kernel, construct the 'make' command to execute.
        arg_list = ["make", #f"--jobs={args.nproc}",
                    f"KERNEL_FILE={kern.kernel_file}",
                    f"ADJ_FILE={kern.adj_file}",
                    f"HARNESS_FILE={kern.harness_file}"]
        geom_args = []
        if name in NO_METADATA_KERNELS:
            arg_list.append("API= ")
        if kern.coord_arg > -1:
            geom_args.append(f"-coord-arg {kern.coord_arg}")
        if kern.panel_id_arg > -1:
            geom_args.append(f"-panel-id-arg {kern.panel_id_arg}")
        if geom_args:
            geom_arg_txt = ' '.join(geom_args)
            arg_list.append(f"GEOM_ARGS={geom_arg_txt}")
        arg_list.append(f"MINI_APP={kern.mini_app}")
        arg_list.extend([f"ACTIVE_VARS={kern.active_vars}", "-f", makefile])

        print(f"Running: '{' '.join(arg_list)}'")
        try:
            complete = subprocess.run(arg_list, check=True,
                                      capture_output=False,
                                      text=True)
            #if "PASSED: " in complete.stdout:
            #    print(f"Test of kernel {name} passed.")
            #else:
            #    print(f"Test of kernel {name} failed:\n{complete.stdout}")
        except OSError as err:
            print(f"Failed to process kernel {name}: {err}",
                  file=sys.stderr)
            continue
        except subprocess.CalledProcessError as err:
            print(f"Build and run of test harness failed:\n{err.output}")
            continue

if __name__ == "__main__":
    main(sys.argv[1:])
