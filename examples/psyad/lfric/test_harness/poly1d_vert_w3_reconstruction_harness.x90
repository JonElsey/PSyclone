module adjoint_test_mod
  implicit none
  public

  contains
  subroutine adjoint_test(mesh, chi, panel_id)
    use field_mod, only : field_type
    use function_space_mod, only : function_space_type
    use mesh_mod, only : mesh_type
    use function_space_collection_mod, only : function_space_collection
    use tl_poly1d_vert_w3_reconstruction_kernel_mod, only : tl_poly1d_vert_w3_reconstruction_kernel_type
    use adj_poly1d_vert_w3_reconstruction_kernel_mod, only : adj_poly1d_vert_w3_reconstruction_kernel_type
    use constants_mod, only : i_def, l_def, r_def
    use fs_continuity_mod, only : w2, w3
    use setop_random_kernel_mod, only : setop_random_kernel_type
    integer(kind=i_def), parameter :: element_order = 1_i_def
    real(kind=r_def), parameter :: overall_tolerance = 1500.0_r_def
    type(mesh_type), pointer, intent(in) :: mesh
    type(field_type), dimension(3), intent(in), optional :: chi
    type(field_type), intent(in), optional :: panel_id
    TYPE(function_space_type), POINTER :: vector_space_w2_ptr
    TYPE(function_space_type), POINTER :: vector_space_w3_ptr
    type(field_type) :: field_1
    type(field_type) :: field_2
    type(field_type) :: field_3
    type(field_type) :: field_4
    type(field_type) :: field_5
    integer(kind=i_def) :: iscalar_6
    integer(kind=i_def) :: iscalar_7
    logical(kind=l_def) :: lscalar_8
    integer(kind=i_def) :: iscalar_6_input
    integer(kind=i_def) :: iscalar_7_input
    logical(kind=l_def) :: lscalar_8_input
    type(field_type) :: field_1_input
    type(field_type) :: field_2_input
    type(field_type) :: field_3_input
    type(field_type) :: field_4_input
    type(field_type) :: field_5_input
    real(kind=r_def) :: field_1_inner_prod
    real(kind=r_def) :: field_2_inner_prod
    real(kind=r_def) :: field_3_inner_prod
    real(kind=r_def) :: field_4_inner_prod
    real(kind=r_def) :: field_5_inner_prod
    real(kind=r_def) :: inner1
    real(kind=r_def) :: field_1_field_1_input_inner_prod
    real(kind=r_def) :: field_2_field_2_input_inner_prod
    real(kind=r_def) :: field_3_field_3_input_inner_prod
    real(kind=r_def) :: field_4_field_4_input_inner_prod
    real(kind=r_def) :: field_5_field_5_input_inner_prod
    real(kind=r_def) :: inner2
    real(kind=r_def) :: MachineTol
    real(kind=r_def) :: relative_diff

    vector_space_w2_ptr => function_space_collection % get_fs(mesh, element_order, w2)
    vector_space_w3_ptr => function_space_collection % get_fs(mesh, element_order, w3)
    call field_1 % initialise(vector_space=vector_space_w2_ptr, name='field_1')
    call field_2 % initialise(vector_space=vector_space_w3_ptr, name='field_2')
    call field_3 % initialise(vector_space=vector_space_w2_ptr, name='field_3')
    call field_4 % initialise(vector_space=vector_space_w3_ptr, name='field_4')
    call field_5 % initialise(vector_space=vector_space_w3_ptr, name='field_5')
    call field_1_input % initialise(vector_space=vector_space_w2_ptr, name='field_1_input')
    call field_2_input % initialise(vector_space=vector_space_w3_ptr, name='field_2_input')
    call field_3_input % initialise(vector_space=vector_space_w2_ptr, name='field_3_input')
    call field_4_input % initialise(vector_space=vector_space_w3_ptr, name='field_4_input')
    call field_5_input % initialise(vector_space=vector_space_w3_ptr, name='field_5_input')
    iscalar_6 = 1_i_def
    iscalar_6_input = iscalar_6
    iscalar_7 = 1_i_def
    iscalar_7_input = iscalar_7
    lscalar_8 = .false._l_def
    field_1_inner_prod = 0.0_r_def
    field_2_inner_prod = 0.0_r_def
    field_3_inner_prod = 0.0_r_def
    field_4_inner_prod = 0.0_r_def
    field_5_inner_prod = 0.0_r_def
    ! Initialise arguments and call the tangent-linear kernel.
    call invoke(setval_random(field_1), setval_x(field_1_input, field_1), setval_random(field_2), setval_x(field_2_input, &
&field_2), setval_random(field_3), setval_x(field_3_input, field_3), setval_random(field_4), setval_x(field_4_input, field_4), &
&setval_random(field_5), setval_x(field_5_input, field_5), tl_poly1d_vert_w3_reconstruction_kernel_type(field_1, field_2, field_3, &
&field_4, field_5, iscalar_6, iscalar_7, lscalar_8), x_innerproduct_x(field_1_inner_prod, field_1), &
&x_innerproduct_x(field_2_inner_prod, field_2), x_innerproduct_x(field_3_inner_prod, field_3), &
&x_innerproduct_x(field_4_inner_prod, field_4), x_innerproduct_x(field_5_inner_prod, field_5))
    inner1 = 0.0_r_def
    inner1 = inner1 + iscalar_6 * iscalar_6
    inner1 = inner1 + iscalar_7 * iscalar_7
    inner1 = inner1 + field_1_inner_prod
    inner1 = inner1 + field_2_inner_prod
    inner1 = inner1 + field_3_inner_prod
    inner1 = inner1 + field_4_inner_prod
    inner1 = inner1 + field_5_inner_prod
    field_1_field_1_input_inner_prod = 0.0_r_def
    field_2_field_2_input_inner_prod = 0.0_r_def
    field_3_field_3_input_inner_prod = 0.0_r_def
    field_4_field_4_input_inner_prod = 0.0_r_def
    field_5_field_5_input_inner_prod = 0.0_r_def
    call invoke(adj_poly1d_vert_w3_reconstruction_kernel_type(field_1, field_2, field_3, field_4, field_5, iscalar_6, iscalar_7, &
&lscalar_8), x_innerproduct_y(field_1_field_1_input_inner_prod, field_1, field_1_input), &
&x_innerproduct_y(field_2_field_2_input_inner_prod, field_2, field_2_input), x_innerproduct_y(field_3_field_3_input_inner_prod, &
&field_3, field_3_input), x_innerproduct_y(field_4_field_4_input_inner_prod, field_4, field_4_input), &
&x_innerproduct_y(field_5_field_5_input_inner_prod, field_5, field_5_input))
    inner2 = 0.0_r_def
    inner2 = inner2 + iscalar_6 * iscalar_6_input
    inner2 = inner2 + iscalar_7 * iscalar_7_input
    inner2 = inner2 + field_1_field_1_input_inner_prod
    inner2 = inner2 + field_2_field_2_input_inner_prod
    inner2 = inner2 + field_3_field_3_input_inner_prod
    inner2 = inner2 + field_4_field_4_input_inner_prod
    inner2 = inner2 + field_5_field_5_input_inner_prod
    ! Test the inner-product values for equality, allowing for the precision of the active variables
    MachineTol = SPACING(MAX(ABS(inner1), ABS(inner2)))
    relative_diff = ABS(inner1 - inner2) / MachineTol
    if (relative_diff < overall_tolerance) then
      WRITE(*, *) 'Test of adjoint of ''tl_poly1d_vert_w3_reconstruction_kernel_type'' PASSED: ', inner1, inner2, relative_diff
    else
      WRITE(*, *) 'Test of adjoint of ''tl_poly1d_vert_w3_reconstruction_kernel_type'' FAILED: ', inner1, inner2, relative_diff
    end if

  end subroutine adjoint_test

end module adjoint_test_mod
